---
layout: post
title: "数组"
date: 2026-02-27 14:30:00 +0800
categories: [code,leetcode]
tags: [code,leetcode]
math: true
toc: true
---

# 数组

## 1. 双指针
> **核心思想**：利用两个指针在序列中以不同规则同向或相向移动，通过排除不可能情况来减少遍历，优化时间复杂度。

### 1.1 快慢指针
*   **主要思路**：两个指针同向移动，一快一慢，常用于处理链表、原地修改数组等场景。
*   **核心题目**：
    *   **LeetCode 26. 删除有序数组中的重复项**：`slow`指针指向待填充位置，`fast`指针向前探索，当遇到`nums[fast] != nums[slow]`时，将其赋值给`nums[++slow]`。最终`nums[0..slow]`为不重复部分。
      python
      class Solution:
      def removeDuplicates(self, nums: List[int]) -> int:
      if not nums:
      return 0
      slow = 0
      for fast in range(1, len(nums)):
      if nums[fast] != nums[slow]:
      slow += 1
      nums[slow] = nums[fast]
      return slow + 1
    *   **LeetCode 27. 移除元素**：类似去重。`fast`指针遇到目标值`val`则跳过，否则将其赋值给`nums[slow]`，然后`slow`前进。最终`nums[0..slow-1]`为移除目标值后的部分。
    *   **LeetCode 283. 移动零**：等价于“移除所有0元素，再将末尾补零”。可先复用“移除元素”逻辑移除0，再将数组剩余部分置零。

### 1.2 左右指针
*   **主要思路**：两个指针从两端或中心向相反方向移动，用于处理有序数组、反转、对称性判断等问题。
*   **核心题目**：
    *   **LeetCode 167. 两数之和 II - 输入有序数组**：`left`从左，`right`从右开始。根据`sum`与`target`比较移动指针：`sum < target`则`left++`，`sum > target`则`right--`，直到找到。
    *   **LeetCode 344. 反转字符串**：`left`和`right`指针分别指向首尾，交换元素后向中间移动，直到相遇。
    *   **LeetCode 5. 最长回文子串**：从中心向两边扩展。遍历每个可能的中心点（一个或两个字符），调用辅助函数向两侧扩展寻找回文。

## 2. 滑动窗口
> **核心思想**：用`left`和`right`指针维护一个窗口，通过移动右指针扩大窗口，移动左指针缩小窗口，在窗口滑动过程中寻找最优解。用于解决**子串/子数组**相关问题。

*   **通用框架**：先扩大窗口(`right++`)，当窗口满足条件时，尝试收缩窗口(`left++`)以优化解，在合适的时机记录结果。
*   **核心题目**：
    *   **LeetCode 76. 最小覆盖子串**：用`need`和`window`记录字符需求。扩大窗口直到包含`t`所有字符，然后收缩窗口以找到最小长度。结果在**收缩窗口时**更新。
    *   **LeetCode 567. 字符串的排列**：维护一个长度等于`s2`的定长窗口，在`s1`中滑动，检查窗口内字符是否满足`s2`的排列。发现满足时立即返回`true`。
    *   **LeetCode 438. 找到字符串中所有字母异位词**：思路同上，但需记录所有满足条件的起始索引。
    *   **LeetCode 3. 无重复字符的最长子串**：当`window[c] > 1`（出现重复字符）时收缩窗口，每次收缩完成后（窗口内无重复）更新最长长度。

## 3. 二分查找
> **核心思想**：在**有序**集合中，每次比较中间元素，舍弃一半不可能的解空间，从而以O(log N)的复杂度高效搜索。

*   **核心模板**：注意**搜索区间**（`[left, right]` 或 `[left, right)`）和**循环终止条件**（`left <= right` 或 `left < right`）的对应。
*   **核心题目**：
    *   **LeetCode 704. 二分查找**：标准二分，找到目标值即返回。
    *   **寻找左边界**：当`nums[mid] == target`时，继续向左搜索 (`right = mid - 1` 或 `right = mid`)。最终检查`left`。
    *   **寻找右边界**：当`nums[mid] == target`时，继续向右搜索 (`left = mid + 1`)。最终检查`right`。
    *   **LeetCode 74. 搜索二维矩阵**：解法1：两次二分（先行后列）。解法2：将二维矩阵虚拟映射为一维数组进行二分，索引转换：`matrix[mid/n][mid%n]`。
    *   **LeetCode 240. 搜索二维矩阵 II**：从**右上角**开始Z字形搜索。若当前值大于目标，则向左移动一列；若小于目标，则向下移动一行。
    *   **LeetCode 162. 寻找峰值**：比较`nums[mid]`与`nums[mid+1]`。若`nums[mid] < nums[mid+1]`，峰值在右侧；否则在左侧（包含`mid`）。
    *   **LeetCode 33. 搜索旋转排序数组**：判断`mid`左右哪部分有序，再判断目标值是否在有序部分内，从而决定搜索区间。

## 4. NSum 问题
> **核心思想**：将N数之和问题递归分解为2Sum问题，利用**排序**和**双指针**解决。

*   **通用递归框架**：先排序，然后递归地将`nSum`转化为`(n-1)Sum`，直至`2Sum`。注意跳过重复组合。
*   **核心题目**：
    *   **LeetCode 1. 两数之和**：基础题，可使用哈希表或排序后双指针。
    *   **LeetCode 15. 三数之和**：调用`nSum(nums, 3, 0, 0)`。递归到`2Sum`时用左右指针法。
    *   **LeetCode 18. 四数之和**：调用`nSum(nums, 4, 0, target)`。递归到`3Sum`，再递归到`2Sum`。

## 5. 前缀和
> **核心思想**：预计算前缀和数组`preSum`，其中`preSum[i] = nums[0] + ... + nums[i-1]`。用于O(1)时间内查询任意区间和。

*   **核心公式**：区间`[left, right]`和 = `preSum[right+1] - preSum[left]`。
*   **核心题目**：
    *   **LeetCode 303. 区域和检索 - 数组不可变**：初始化时构建`preSum`数组，`sumRange`方法直接通过减法返回结果。
    *   **LeetCode 304. 二维区域和检索 - 矩阵不可变**：构建二维`preSum`，`preSum[i][j]`表示`(0,0)`到`(i-1,j-1)`的和。子矩阵`(r1,c1)`到`(r2,c2)`的和 = `preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1]`。

## 6. 差分数组
> **核心思想**：构建差分数组`diff`，其中`diff[i] = nums[i] - nums[i-1]`。用于O(1)时间内对原始数组的任意区间进行增减操作。

*   **核心操作**：对区间`[i, j]`加`val`：`diff[i] += val; diff[j+1] -= val`。最后对`diff`求前缀和还原修改后的`nums`。
*   **核心题目**：
    *   **LeetCode 370. 区间加法**：差分数组的模板题。用`Difference`类处理多次区间加法指令，最后返回结果数组。
    *   **LeetCode 1109. 航班预订统计**：将每个预订`(first, last, seats)`转化为对数组区间`[first-1, last-1]`加`seats`的差分操作。
    *   **LeetCode 1094. 拼车**：将每个旅程`(numPassengers, from, to)`转化为对区间`[from, to-1]`加`numPassengers`的差分操作。最后检查每个“车站”的人数是否超过`capacity`。

---
**总结**：上述算法技巧是解决一系列高频面试题的核心。掌握其思想、模板和经典例题，便能以不变应万变。


