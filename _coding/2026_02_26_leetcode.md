---
layout: post
title: "LeetCode"
date: 2026-02-27 14:30:00 +0800
categories: [code,leetcode]
tags: [code,leetcode]
math: true
toc: true
---

# 数组

## 1. 双指针
> **核心思想**：利用两个指针在序列中以不同规则同向或相向移动，通过排除不可能情况来减少遍历，优化时间复杂度。

### 1.1 快慢指针
*   **主要思路**：两个指针同向移动，一快一慢，常用于处理链表、原地修改数组等场景。
*   **核心题目**：
    *   **LeetCode 26. 删除有序数组中的重复项**：`slow`指针指向待填充位置，`fast`指针向前探索，当遇到`nums[fast] != nums[slow]`时，将其赋值给`nums[++slow]`。最终`nums[0..slow]`为不重复部分。
      python
      class Solution:
      def removeDuplicates(self, nums: List[int]) -> int:
      if not nums:
      return 0
      slow = 0
      for fast in range(1, len(nums)):
      if nums[fast] != nums[slow]:
      slow += 1
      nums[slow] = nums[fast]
      return slow + 1
    *   **LeetCode 27. 移除元素**：类似去重。`fast`指针遇到目标值`val`则跳过，否则将其赋值给`nums[slow]`，然后`slow`前进。最终`nums[0..slow-1]`为移除目标值后的部分。
    *   **LeetCode 283. 移动零**：等价于“移除所有0元素，再将末尾补零”。可先复用“移除元素”逻辑移除0，再将数组剩余部分置零。

### 1.2 左右指针
*   **主要思路**：两个指针从两端或中心向相反方向移动，用于处理有序数组、反转、对称性判断等问题。
*   **核心题目**：
    *   **LeetCode 167. 两数之和 II - 输入有序数组**：`left`从左，`right`从右开始。根据`sum`与`target`比较移动指针：`sum < target`则`left++`，`sum > target`则`right--`，直到找到。
    *   **LeetCode 344. 反转字符串**：`left`和`right`指针分别指向首尾，交换元素后向中间移动，直到相遇。
    *   **LeetCode 5. 最长回文子串**：从中心向两边扩展。遍历每个可能的中心点（一个或两个字符），调用辅助函数向两侧扩展寻找回文。

## 2. 滑动窗口
> **核心思想**：用`left`和`right`指针维护一个窗口，通过移动右指针扩大窗口，移动左指针缩小窗口，在窗口滑动过程中寻找最优解。用于解决**子串/子数组**相关问题。

*   **通用框架**：先扩大窗口(`right++`)，当窗口满足条件时，尝试收缩窗口(`left++`)以优化解，在合适的时机记录结果。
*   **核心题目**：
    *   **LeetCode 76. 最小覆盖子串**：用`need`和`window`记录字符需求。扩大窗口直到包含`t`所有字符，然后收缩窗口以找到最小长度。结果在**收缩窗口时**更新。
    *   **LeetCode 567. 字符串的排列**：维护一个长度等于`s2`的定长窗口，在`s1`中滑动，检查窗口内字符是否满足`s2`的排列。发现满足时立即返回`true`。
    *   **LeetCode 438. 找到字符串中所有字母异位词**：思路同上，但需记录所有满足条件的起始索引。
    *   **LeetCode 3. 无重复字符的最长子串**：当`window[c] > 1`（出现重复字符）时收缩窗口，每次收缩完成后（窗口内无重复）更新最长长度。

## 3. 二分查找
> **核心思想**：在**有序**集合中，每次比较中间元素，舍弃一半不可能的解空间，从而以O(log N)的复杂度高效搜索。

*   **核心模板**：注意**搜索区间**（`[left, right]` 或 `[left, right)`）和**循环终止条件**（`left <= right` 或 `left < right`）的对应。
*   **核心题目**：
    *   **LeetCode 704. 二分查找**：标准二分，找到目标值即返回。
    *   **寻找左边界**：当`nums[mid] == target`时，继续向左搜索 (`right = mid - 1` 或 `right = mid`)。最终检查`left`。
    *   **寻找右边界**：当`nums[mid] == target`时，继续向右搜索 (`left = mid + 1`)。最终检查`right`。
    *   **LeetCode 74. 搜索二维矩阵**：解法1：两次二分（先行后列）。解法2：将二维矩阵虚拟映射为一维数组进行二分，索引转换：`matrix[mid/n][mid%n]`。
    *   **LeetCode 240. 搜索二维矩阵 II**：从**右上角**开始Z字形搜索。若当前值大于目标，则向左移动一列；若小于目标，则向下移动一行。
    *   **LeetCode 162. 寻找峰值**：比较`nums[mid]`与`nums[mid+1]`。若`nums[mid] < nums[mid+1]`，峰值在右侧；否则在左侧（包含`mid`）。
    *   **LeetCode 33. 搜索旋转排序数组**：判断`mid`左右哪部分有序，再判断目标值是否在有序部分内，从而决定搜索区间。

## 4. NSum 问题
> **核心思想**：将N数之和问题递归分解为2Sum问题，利用**排序**和**双指针**解决。

*   **通用递归框架**：先排序，然后递归地将`nSum`转化为`(n-1)Sum`，直至`2Sum`。注意跳过重复组合。
*   **核心题目**：
    *   **LeetCode 1. 两数之和**：基础题，可使用哈希表或排序后双指针。
    *   **LeetCode 15. 三数之和**：调用`nSum(nums, 3, 0, 0)`。递归到`2Sum`时用左右指针法。
    *   **LeetCode 18. 四数之和**：调用`nSum(nums, 4, 0, target)`。递归到`3Sum`，再递归到`2Sum`。

## 5. 前缀和
> **核心思想**：预计算前缀和数组`preSum`，其中`preSum[i] = nums[0] + ... + nums[i-1]`。用于O(1)时间内查询任意区间和。

*   **核心公式**：区间`[left, right]`和 = `preSum[right+1] - preSum[left]`。
*   **核心题目**：
    *   **LeetCode 303. 区域和检索 - 数组不可变**：初始化时构建`preSum`数组，`sumRange`方法直接通过减法返回结果。
    *   **LeetCode 304. 二维区域和检索 - 矩阵不可变**：构建二维`preSum`，`preSum[i][j]`表示`(0,0)`到`(i-1,j-1)`的和。子矩阵`(r1,c1)`到`(r2,c2)`的和 = `preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1]`。

## 6. 差分数组
> **核心思想**：构建差分数组`diff`，其中`diff[i] = nums[i] - nums[i-1]`。用于O(1)时间内对原始数组的任意区间进行增减操作。

*   **核心操作**：对区间`[i, j]`加`val`：`diff[i] += val; diff[j+1] -= val`。最后对`diff`求前缀和还原修改后的`nums`。
*   **核心题目**：
    *   **LeetCode 370. 区间加法**：差分数组的模板题。用`Difference`类处理多次区间加法指令，最后返回结果数组。
    *   **LeetCode 1109. 航班预订统计**：将每个预订`(first, last, seats)`转化为对数组区间`[first-1, last-1]`加`seats`的差分操作。
    *   **LeetCode 1094. 拼车**：将每个旅程`(numPassengers, from, to)`转化为对区间`[from, to-1]`加`numPassengers`的差分操作。最后检查每个“车站”的人数是否超过`capacity`。

---
**总结**：上述算法技巧是解决一系列高频面试题的核心。掌握其思想、模板和经典例题，便能以不变应万变。



# 链表算法核心技巧总结

## 一、链表双指针技巧

### 1. 合并两个有序链表
**题型**：合并两个有序链表为新有序链表  
**思路**：
- 使用双指针 `p1`、`p2` 分别遍历两链表
- 比较节点值，将较小值接入新链表
- 通过**虚拟头节点**简化边界处理
- 时间复杂度 O(m+n)，空间复杂度 O(1)

### 2. 链表的分解
**题型**：按特定值分割链表为两部分  
**思路**：
- 创建两个新链表（小链表/大链表）
- 遍历原链表，按条件将节点接入对应链表
- 最后连接两个链表
- **关键**：断开原链表节点连接避免成环

### 3. 合并K个有序链表
**题型**：合并多个有序链表  
**思路**：
- 使用**优先级队列（最小堆）** 维护各链表头节点
- 每次取出最小值接入结果链表
- 时间复杂度 O(Nlogk)，N为总节点数

### 4. 单链表的倒数第k个节点
**题型**：一次遍历找到倒数第k节点  
**思路**：
1. 快指针先走k步
2. 慢指针从头开始，两指针同步前进
3. 快指针到末尾时，慢指针指向目标
- **扩展**：删除倒数第k节点需找倒数第k+1节点

### 5. 单链表的中点
**题型**：一次遍历找到链表中点  
**思路**：
- 快慢指针（慢1步/快2步）
- 快指针到末尾时，慢指针指向中点
- 链表长度为偶数时返回靠后节点

### 6. 判断链表环及环起点
**题型**：检测环并找到环起点  
**思路**：
1. **检测环**：快慢指针，相遇则有环
2. **找起点**：相遇后重置一指针到头，同速前进，再相遇点即为环起点
- 数学原理：相遇时慢走k步，快走2k步

### 7. 两个链表是否相交
**题型**：判断两链表是否相交并返回交点  
**思路**：
- **拼接法**：p1遍历A后遍历B，p2遍历B后遍历A，两指针会同时到达交点
- **长度对齐法**：计算长度差，长链表指针先走差步，再同步找交点
- 空间复杂度 O(1)

---

## 二、链表反转技巧

### 1. 反转整个单链表（LeetCode 206）
**题型**：完全反转单链表  
**思路**：
- **迭代法**：
  - 三指针：`pre`、`cur`、`nxt`
  - 遍历链表，将每个节点的 `next` 指向前驱
  - 空间复杂度 O(1)
- **递归法**：
  - 分解问题：递归反转剩余链表，将头节点接至末尾
  - Base case：空链表或单节点直接返回
  - 空间复杂度 O(N)

### 2. 反转链表前N个节点
**题型**：仅反转前N个节点  
**思路**：
- **递归法**：
  - 类似整体反转，但记录第N+1节点（`successor`）
  - Base case：N=1时记录后继节点
- **迭代法**：
  - 控制反转节点数量
  - 记录反转区间前后节点以便连接

### 3. 反转链表的一部分（LeetCode 92）
**题型**：反转指定区间 [left, right]  
**思路**：
- **递归法**：
  - 若 left=1，转化为反转前right个节点
  - 若 left>1，head.next 是反转区间 [left-1, right-1]
- **迭代法**：
  1. 找到第 left-1 节点（前驱）
  2. 反转区间节点
  3. 连接前后部分

### 4. K个一组反转链表（LeetCode 25）
**题型**：每K个节点一组反转  
**思路**：
- **递归法**：
  1. 判断剩余节点是否足够K个
  2. 足够：反转前K个，递归处理剩余
  3. 不足：直接返回
- **迭代法**：
  1. 使用虚拟头节点
  2. 分组处理，连接各组
  3. 移动指针到下一组

---

## 三、通用技巧总结

### 核心技巧
1. **虚拟头节点**：简化边界条件处理
2. **快慢指针**：解决中点、环检测、倒数节点问题
3. **多指针协同**：`pre`、`cur`、`nxt` 配合操作
4. **优先级队列**：优化多链表合并

### 递归思维
- **分解问题**：将大问题分解为相同结构的子问题
- **明确递归定义**：清楚函数输入输出含义
- **Base case**：正确处理递归终止

### 注意事项
1. 操作 `nxt.next` 前先判断 `nxt` 是否为 null
2. 反转链表时注意断链重连顺序
3. 迭代解法空间效率更高（O(1)），递归代码更简洁但空间 O(N)

---

**文档未详述但基于知识补充**：以上总结基于提供的两篇技术文章，涵盖了链表操作中最核心的双指针和反转两大主题。实际面试和算法竞赛中，这些技巧的组合运用可以解决绝大多数单链表相关问题。
